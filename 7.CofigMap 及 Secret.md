[TOC]

# ConfigMap

[REFERENCE](https://kubernetes.io/zh/docs/tasks/configure-pod-container/configure-pod-configmap/)

一般用 ConfigMap 去管理一些配置文件、或者一些大量的环境变量信息。ConfigMap 将配置和 Pod 分开，有个 nginx，nginx.conf -> configmap.nginx 更易于配置的更改和管理。

## 1.创建 ConfigMap
### (1).基于文件创建 ConfigMap

这个是生产环境最常用的。显示的格式是 key=value 的格式

```shell
# 创建本地目录
mkdir -p /root/manifests/configmap/

# 创建配置文件
cat > manifests/configmap/game.properties <<EOF
enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30

# 创建 configmap
kubectl create configmap game-config-1 --from-file=manifests/configmap/game.properties

# 查看 configmap manifests/configmap/ 目录中的 game.properties文件内容出现在 ConfigMap 的 data 部分。显示的格式是 key=value 的这种格式。
kubectl get cm
kubectl describe configmaps game-config
kubectl get configmaps game-config -o yaml
```

`--from-file` 里面的格式是 key=value 

`--from-env-file` 里面的格式是 key:value

- Env 文件中的每一行必须为 VAR=VAL 格式。
- 以＃开头的行（即注释）将被忽略。
- 空行将被忽略。
- 引号不会被特殊处理（即它们将成为 ConfigMap 值的一部分）。

```shell
cat > manifests/configmap/game-env-file.properties << EOF
enemies=aliens
lives=3
allowed="true"

# This comment and the empty line above it are ignored
EOF

# 创建 ConfigMap
kubectl create configmap game-config-env-file --from-env-file=manifests/configmap/game-env-file.properties

# 这种在 configmap 里面显示是 key: value 的格式，而上面是 key=value 的格式。而且空行和# 都会被忽略
kubectl get configmap game-config-env-file -o yaml
```

当多次使用 `--from-env-file` 来从多个数据源创建 ConfigMap 时，仅仅最后一个 env 文件有效。



### (2).基于目录创建 ConfigMap

你可以使用 `kubectl create configmap` 基于同一目录中的多个文件创建 ConfigMap。 当你基于目录来创建 ConfigMap 时，kubectl 识别目录下基本名可以作为合法键名的 文件，并将这些文件打包到新的 ConfigMap 中。普通文件之外的所有目录项都会被 忽略（例如，子目录、符号链接、设备、管道等等）。生产环境比较少用。显示的格式是 key=value 的格式

```shell

# 创建配置文件
cat > manifests/configmap/game.properties <<EOF
enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30

cat > manifests/configmap/ui.properties <<EOF
color.good=purple
color.bad=yellow
allow.textmode=true
how.nice.to.look=fairlyNice
EOF

# 创建 configmap
kubectl create configmap game-config-2 --from-file=manifests/configmap/

# 查看 configmap manifests/configmap/ 目录中的 game.properties 和 ui.properties 文件内容出现在 ConfigMap 的 data 部分。
kubectl get cm
kubectl describe configmaps game-config
kubectl get configmaps game-config -o yaml
```

### (3).直接从 key=value 创建

这种不常用的。显示的格式 key:value 的格式

```shell
kubectl create configmap special-config --from-literal=special.how=very --from-literal=special.type=charm

kubectl get configmaps special-config -o yaml
```

### (4).基于生成器创建 ConfigMap

[REFERENCE](https://kubernetes.io/zh/docs/tasks/configure-pod-container/configure-pod-configmap/#%E5%9F%BA%E4%BA%8E%E7%94%9F%E6%88%90%E5%99%A8%E5%88%9B%E5%BB%BA-configmap)

这个从1.14版本开始的。现在k8s已经在推这种方式了。

```shell
# redis 配置文件
cat > config/redis-config <<EOF
maxmemory 2mb
maxmemory-policy allkeys-lru
EOF

# 创建 configmap
cat <<EOF >./kustomization.yaml
configMapGenerator:
- name: example-redis-config
  files:
  - redis-config
EOF

kubectl apply -k kustomization.yaml

# 创建 pod 引用 configmap
cat > configmap/redis-pod.yaml <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: redis
spec:
  containers:
  - name: redis
    image: redis:5.0.4
    command:
      - redis-server
      - "/redis-master/redis.conf"
    env:
    - name: MASTER
      value: "true"
    ports:
    - containerPort: 6379
    resources:
      limits:
        cpu: "0.1"
    volumeMounts:
    - mountPath: /redis-master-data
      name: data
    - mountPath: /redis-master
      name: config
  volumes:
    - name: data
      emptyDir: {}
    - name: config
      configMap:
        name: example-redis-config
        items:
        - key: redis-config
          path: redis.conf
EOF

kubectl apply -f configmap/redis-pod.yaml
```



## 2.使用 ConfigMap

### (1).使用单个 ConfigMap 绑定容器中的环境变量

生产用的不多。

```shell
# 创建 configmap
kubectl create configmap special-config1 --from-literal=special.how=very

# 创建 Pod
cat > pod-single-configmap-env-variable.yaml << EOF
apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod
spec:
  containers:
    - name: test-container
      image: busybox
      command: [ "/bin/sh", "-c", "env" ]
      env:
        # 定义变量的名字
        - name: SPECIAL_LEVEL_KEY
          valueFrom:
            configMapKeyRef:
              # 包含要分配给 SPECIAL_LEVEL_KEY 的值的 ConfigMap
              name: special-config1
              # 将 special-config1 ConfigMap中的 special.how 的值 绑定 SPECIAL_LEVEL_KEY 这个变量
              key: special.how
  restartPolicy: Never
EOF

kubectl apply -f pod-single-configmap-env-variable.yaml
kubectl get pod dapi-test-pod -o yaml | egrep '    env:' -A 5

```

### (2).使用多个 ConfigMap 绑定容器中的环境变量

生产用的不多。

```shell
# 创建多个 configmap
cat > configmap/configmaps.yaml <<EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: special-config2
  namespace: default
data:
  special.how: very
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: env-config2
  namespace: default
data:
  log_level: INFO
EOF

kubectl apply -f configmap/configmaps.yaml

# 创建 Pod
cat > configmap/pod-multiple-configmap-env-variable.yaml << EOF
apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod1
spec:
  containers:
    - name: test-container
      image: busybox
      command: [ "/bin/sh", "-c", "env" ]
      env:
        - name: SPECIAL_LEVEL_KEY
          valueFrom:
            configMapKeyRef:
              name: special-config2
              key: special.how
        - name: LOG_LEVEL
          valueFrom:
            configMapKeyRef:
              name: env-config2
              key: log_level
  restartPolicy: Never
EOF

kubectl apply -f configmap/pod-multiple-configmap-env-variable.yaml

kubectl get pod dapi-test-pod1 -o yaml | egrep '    env:' -A 10
```

### (3).直接 Pod yaml 定义变量



```shell
# 创建 Pod
cat > configmap/pod-multiple.yaml << EOF
apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod1
spec:
  containers:
    - name: test-container
      image: busybox
      command: [ "/bin/sh", "-c", "env" ]
      env:
        - name: SPECIAL_LEVEL_KEY
          value: test
        - name: LOG_LEVEL
          value: test1
        - name: MYSQL_PASSWORD
          value: ldakdsifqpieu
        - name: MYSQL_PORT
          value: "3307"
  restartPolicy: Never
EOF

kubectl apply -f configmap/pod-multiple.yaml

kubectl get pod dapi-test-pod1 -o yaml | egrep '    env:' -A 10
```

### (4).将 ConfigMap 中的所有键值对绑定为容器环境变量

生产中常用。

```shell
# 创建 configmap
cat > configmap/configmap-multikeys.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: special-config3
  namespace: default
data:
  SPECIAL_LEVEL: very
  SPECIAL_TYPE: charm
EOF

kubectl apply -f configmap/configmap-multikeys.yaml

# 使用 envFrom 将所有 ConfigMap 的数据定义为容器环境变量，ConfigMap 中的键成为 Pod 中的环境变量名称。

cat > configmap/pod-configmap-envFrom.yaml << EOF
apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod3
spec:
  containers:
    - name: test-container
      image: k8s.gcr.io/busybox
      command: [ "/bin/sh", "-c", "env" ]
      envFrom:
      - configMapRef:
          name: special-config
  restartPolicy: Never
EOF

kubectl apply -f configmap/pod-configmap-envFrom.yaml
kubectl logs -f dapi-test-pod3 | egrep "SPECIAL_LEVEL|SPECIAL_TYPE"

# 使用 valueFrom 将 secret 的key的值赋值给变量，可以使用 $(VAR_NAME) Kubernetes 替换语法在容器的 command 和 args 部分中使用 ConfigMap 定义的环境变量。
cat > configmap/pod-configmap-valueFrom.yaml << EOF
apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod4
spec:
  containers:
    - name: test-container
      image: k8s.gcr.io/busybox
      command: [ "/bin/sh", "-c", "echo $(SPECIAL_LEVEL_KEY) $(SPECIAL_TYPE_KEY)" ]
      env:
        - name: SPECIAL_LEVEL_KEY
          valueFrom:
            configMapKeyRef:
              name: special-config
              key: SPECIAL_LEVEL
        - name: SPECIAL_TYPE_KEY
          valueFrom:
            configMapKeyRef:
              name: special-config
              key: SPECIAL_TYPE
  restartPolicy: Never
EOF

kubectl apply -f configmap/pod-configmap-valueFrom.yaml
kubectl logs -f dapi-test-pod4
```

### (5).将 ConfigMap 添加到一个卷

如基于文件创建 [ConfigMap](https://kubernetes.io/zh/docs/tasks/configure-pod-container/configure-pod-configmap/#create-configmaps-from-files) 中所述，当你使用 `--from-file` 创建 ConfigMap 时，文件名成为存储在 ConfigMap 的 `data` 部分中的键， 文件内容成为键对应的值。

```shell
cat > configmap/configmap-multikeys.yaml <<EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: special-config5
  namespace: default
data:
  SPECIAL_LEVEL: very
  SPECIAL_TYPE: charm
EOF

kubectl apply -f configmap/configmap-multikeys.yaml

#在 Pod 规约的 volumes 部分下添加 ConfigMap 名称。 这会将 ConfigMap 数据添加到指定为 volumeMounts.mountPath 的目录（在本例中为 /etc/config）。 command 部分引用存储在 ConfigMap 中的 special.level。
cat > pods/pod-configmap-volume.yaml <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod5
spec:
  containers:
    - name: test-container
      image: k8s.gcr.io/busybox
      command: [ "/bin/sh", "-c", "ls /etc/config/" ] # 如果在 /etc/config/ 目录中有一些文件，它们将被删除。
      volumeMounts:
      - name: config-volume
        mountPath: /etc/config
  volumes:
    - name: config-volume
      configMap:
        # Provide the name of the ConfigMap containing the files you want to add to the container
        name: special-config
  restartPolicy: Never
EOF

kubectl apply -f pods/pod-configmap-volume.yaml
kubectl logs -f dapi-test-pod5


# 使用 path 字段为特定的 ConfigMap 项目指定预期的文件路径。 在这里，SPECIAL_LEVEL 将挂载在 config-volume 数据卷中 /etc/config/keys 目录下。
cat > pods/pod-configmap-volume-specific-key.yaml <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod
spec:
  containers:
    - name: test-container
      image: k8s.gcr.io/busybox
      command: [ "/bin/sh","-c","cat /etc/config/keys" ] # /etc/config/ 目录中所有先前的文件都将被删除。
      volumeMounts:
      - name: config-volume
        mountPath: /etc/config
  volumes:
    - name: config-volume
      configMap:
        name: special-config
        items:
        - key: SPECIAL_LEVEL
          path: keys
  restartPolicy: Never
EOF
```

`subPath` 可以使挂载不会被覆盖，上面的例子会把/etc/nginx/所有文件都覆盖掉。subPaht 解决目录被覆盖的问题。

```shell
kubectl create deploy nginx-de --image=nginx
kubectl exec -it nginx-de-7d7f68c67-gpq7q -- cat /etc/nginx/nginx.conf > nginx.conf
kubectl create cm nginx-conf --from-file=nginx.conf

cat <<EOF | kubectl apply -f
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-de
  namespace: default
spec:
  replicas: 2
  selector:
    matchLabels:
      app: test
      release: canary
  template:
    metadata:
      labels:
        app: test
        release: canary
    spec:
      containers:
      - name: nginx
        image: nginx
        imagePullPolicy: IfNotPresent
        ports:
        - name: http
          containerPort: 80
        resources:
          limits:
            cpu: 10m
            memory: 10Mi
          requests:
            cpu: 3m
            memory: 3Mi
        volumeMounts:
          - name: config-volume
            mountPath: /etc/nginx/nginx.conf
            subPath: etc/nginx/nginx.conf  # 这里不要加上/
      volumes:
      - name: config-volume
        configMap:
          name: nginx-conf
          items:
          - key: nginx.conf  # 这个是 data 中的key
            path: etc/nginx/nginx.conf   # 这里不要加上/
EOF

# 可以看到 /etc/nginx 下的文件都在
kubectl exec -it nginx-de-7cd844b84c-5rb6h -- ls /etc/nginx/
```

# Secret

[REFERENCE](https://kubernetes.io/zh/docs/concepts/configuration/secret/)

用来保存敏感信息，比如密码、令牌或者 Key、Redis、MySQL密码。Secret 更倾向于存储和共享敏感、加密的配置信息。作用和 ConfigMap 是一样的管理配置文件、环境变量。

## 1.Secret 类型

[REFERENCE](https://kubernetes.io/zh/docs/concepts/configuration/secret/#secret-types)

| **内置类型** | **用法** |
| -------- | ---- |
| Opaque | 用户定义的任意数据，type字段为空，则默认是Opaque |
| kubernetes.io/service-account-token | 服务账号令牌 |
| kubernetes.io/dockercfg | `~/.dockercfg` 文件的序列化形式 |
| kubernetes.io/dockerconfigjson | `~/.docker/config.json` 文件的序列化形式 |
| kubernetes.io/basic-auth | 用于基本身份认证的凭据 |
| kubernetes.io/ssh-auth | 用于 SSH 身份认证的凭据 |
| kubernetes.io/tls | 用于 TLS 客户端或者服务器端的数据 |
| bootstrap.kubernetes.io/token | 启动引导令牌数据 |

### Opaque Secret

```shell
kubectl create secret generic empty-secret
kubectl get secret empty-secret
```

### Service-account-token Secret

```shell
apiVersion: v1
kind: Secret
metadata:
  name: secret-sa-sample
  annotations:
    kubernetes.io/service-account.name: "sa-name"
type: kubernetes.io/service-account-token
data:
  # 你可以像 Opaque Secret 一样在这里添加额外的键/值偶对
  extra: YmFyCg==
```

### Docker Secret

```shell
# kubernetes.io/dockercfg 类型
apiVersion: v1
kind: Secret
metadata:
  name: secret-dockercfg
type: kubernetes.io/dockercfg
data:
  .dockercfg: |
        "<base64 encoded ~/.dockercfg file>"

# kubernetes.io/dockerconfigjson 类型
kubectl create secret docker-registry secret-tiger-docker \
  --docker-username=tiger \
  --docker-password=pass113 \
  --docker-email=tiger@acme.com

kubectl get secret secret-tiger-docker -o yaml
```

### Basic-auth Secret

```shell
apiVersion: v1
kind: Secret
metadata:
  name: secret-basic-auth
type: kubernetes.io/basic-auth
stringData:
  username: admin
  password: t0p-Secret
```

### SSH-auth Secret

Kubernetes 所提供的内置类型 `kubernetes.io/ssh-auth` 用来存放 SSH 身份认证中 所需要的凭据。使用这种 Secret 类型时，你就必须在其 `data` （或 `stringData`） 字段中提供一个 `ssh-privatekey` 键值对，作为要使用的 SSH 凭据。SSH 私钥自身无法建立 SSH 客户端与服务器端之间的可信连接。 需要其它方式来建立这种信任关系，以缓解“中间人（Man In The Middle）” 攻击，例如向 ConfigMap 中添加一个 `known_hosts` 文件。

```shell
apiVersion: v1
kind: Secret
metadata:
  name: secret-ssh-auth
type: kubernetes.io/ssh-auth
data:
  # 此例中的实际数据被截断
  ssh-privatekey: |
          MIIEpQIBAAKCAQEAulqb/Y ...
```

### TLS Secret

Kubernetes 提供一种内置的 `kubernetes.io/tls` Secret 类型，用来存放证书 及其相关密钥（通常用在 TLS 场合）。 此类数据主要提供给 Ingress 资源，用以终结 TLS 链接，不过也可以用于其他 资源或者负载。当使用此类型的 Secret 时，Secret 配置中的 `data` （或 `stringData`）字段必须包含 `tls.key` 和 `tls.crt` 主键，尽管 API 服务器 实际上并不会对每个键的取值作进一步的合法性检查。

```shell
apiVersion: v1
kind: Secret
metadata:
  name: secret-tls
type: kubernetes.io/tls
data:
  # 此例中的数据被截断
  tls.crt: |
        MIIC2DCCAcCgAwIBAgIBATANBgkqh ...
  tls.key: |
        MIIEpgIBAAKCAQEA7yn3bRHQ5FHMQ ...

# 或者
kubectl create secret tls my-tls-secret \
  --cert=path/to/cert/file \
  --key=path/to/key/file
```

### Bootstra-token Secret

通过将 Secret 的 `type` 设置为 `bootstrap.kubernetes.io/token` 可以创建 启动引导令牌类型的 Secret。这种类型的 Secret 被设计用来支持节点的启动引导过程。 其中包含用来为周知的 ConfigMap 签名的令牌。

启动引导令牌 Secret 通常创建于 `kube-system` 名字空间内，并以 `bootstrap-token-<令牌 ID>` 的形式命名；其中 `<令牌 ID>` 是一个由 6 个字符组成 的字符串，用作令牌的标识。

```shell
apiVersion: v1
kind: Secret
metadata:
  # 注意 Secret 的命名方式
  name: bootstrap-token-5emitj
  # 启动引导令牌 Secret 通常位于 kube-system 名字空间
  namespace: kube-system
type: bootstrap.kubernetes.io/token
stringData:
  auth-extra-groups: "system:bootstrappers:kubeadm:default-node-token"
  expiration: "2020-09-13T04:39:10Z"
  # 此令牌 ID 被用于生成 Secret 名称
  token-id: "5emitj"
  token-secret: "kq4gihvszzgn1p0r"
  # 此令牌还可用于 authentication （身份认证）
  usage-bootstrap-authentication: "true"
  # 且可用于 signing （证书签名）
  usage-bootstrap-signing: "true"
```

## 2.创建 Secret

```shell
mkdir ~/manifests/secret
```

### (1).使用 kubectl 管理 Secret

[REFERENCE](https://kubernetes.io/zh/docs/tasks/configmap-secret/managing-secret-using-kubectl/)

**创建Secret**

一个 `Secret` 可以包含 Pod 访问数据库所需的用户凭证。 例如，由用户名和密码组成的数据库连接字符串。 在文件中使用的特殊字符是不需要转义操作的

```shell
# -n 标志确保生成的文件在文本末尾不包含额外的换行符。 这一点很重要，因为当 kubectl 读取文件并将内容编码为 base64 字符串时，多余的换行符也会被编码。
echo -n 'admin' > manifests/secret/username.txt
echo -n '1f2d1e2e67df' > manifests/secret/password.txt

# 创建 secret，默认密钥名称是文件名
kubectl create secret generic db-user-pass \
  --from-file=manifests/secret/username.txt \
  --from-file=manifests/secret/password.txt
  
# 默认密钥名称是文件名。 你可以选择使用 --from-file=[key=]source 来设置密钥名称。
kubectl create secret generic db-user-pass1 \
  --from-file=username=manifests/secret/username.txt \
  --from-file=password=manifests/secret/password.txt
```

**查看 Secret**

```shell
kubectl get secret
kubectl describe secret db-user-pass1
kubectl get secret db-user-pass1 -o yaml
```

**解码 Secret**

```shell
# 获取 secret data内容
kubectl get secret db-user-pass1 -o jsonpath='{.data}'

# 解码 username
echo 'YWRtaW4=' | base64 --decode

# 解码 password
echo 'MWYyZDFlMmU2N2Rm' | base64 --decode
```

**删除 Secret**

```shell
kubectl delete secret db-user-pass
```

### (2).使用配置文件管理 Secret

[REFERENCE](https://kubernetes.io/zh/docs/tasks/configmap-secret/managing-secret-using-config-file/)

你可以先用 JSON 或 YAML 格式在文件中创建 Secret，然后创建该对象。 [Secret](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#secret-v1-core) 资源包含2个键值对： `data` 和 `stringData`。 `data` 字段用来存储 base64 编码的任意数据。 提供 `stringData` 字段是为了方便，它允许 Secret 使用未编码的字符串。 `data` 和 `stringData` 的键必须由字母、数字、`-`，`_` 或 `.` 组成。注意，Secret 对象的名称必须是有效的 [DNS 子域名](https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/names#dns-subdomain-names).

```shell
# 创建Secret配置文件，先将敏感信息先加密
echo -n 'admin' | base64
echo -n '1f2d1e2e67df' | base64

# 创建 Secret yaml文件
cat > secret/mysql-secret.yaml << EOF
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  username: YWRtaW4=
  password: MWYyZDFlMmU2N2Rm
EOF

kubectl apply -f secret/mysql-secret.yaml

# 查看
kubectl get secret
kubectl describe secret mysecret
kubectl get secret mysecret -o yaml

# 解码
echo -n 'YWRtaW4=' | base64 --decode
echo -n 'MWYyZDFlMmU2N2Rm' | base64 --decode
```

如果在 `data` 和 `stringData` 同时出现，比如都有 `username`，只有 `stringData` 的字段才生效，指定了 stringData 不需要手动进行加密，secret 会自动进行将 stringData 下面的键值进行加密。

```shell
# 创建 Secret yaml文件，会自动将
cat > secret/secret-stringdata.yaml << EOF
apiVersion: v1
kind: Secret
metadata:
  name: mysecret-stringdata
type: Opaque
data:
  username: YWRtaW4=
stringData:
  username: k8sadmin
  password: passwor122d
EOF

kubectl apply -f secret/secret-stringdata.yaml

# 查看
kubectl get secret
kubectl describe secret mysecret
kubectl get secret mysecret -o yaml

# 解密
echo "cGFzc3dvcjEyMmQ=" | base64 --decode
echo "azhzYWRtaW4=" | base64 --decode
```

### (3).使用 Kustomize 管理 Secret

[REFERENCE](https://kubernetes.io/zh/docs/tasks/configmap-secret/managing-secret-using-kustomize/)

从 kubernetes v1.14 开始，`kubectl` 支持[使用 Kustomize 管理对象](https://kubernetes.io/zh/docs/tasks/manage-kubernetes-objects/kustomization/)。 Kustomize 提供了资源生成器（Generators）来创建 Secret 和 ConfigMap。 Kustomize 生成器应该在某个目录的 `kustomization.yaml` 文件中指定。 生成 Secret 后，你可以使用 `kubectl apply` 在 API 服务器上创建该 Secret。

## 3.使用 Secret

在使用方面是和 ConfigMap 是一样的，

### (1).将 Secret 添加到一个卷

生产环境常用。

```shell
# 创建 secret
kubectl create secret generic test-secret --from-literal='username=my-app' --from-literal='password=39528$vdg7Jb'

# 创建 Pod 挂载 Secret
cat > pods/secret-pod.yaml <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: secret-test-pod
spec:
  containers:
    - name: test-container
      image: nginx
      volumeMounts:
        # name 必须和下面的 volumes 的 name 是一样的
        - name: secret-volume
          mountPath: /etc/secret-volume
  # The secret data is exposed to Containers in the Pod through a Volume.
  volumes:
    - name: secret-volume
      secret:
        secretName: test-secret
EOF

kubectl create -f secret-pod.yaml

# 查看
kubectl get secret
kubectl get pod secret-test-pod

# 进入容器查看
kubectl exec -it secret-test-pod -- /bin/bash
ls /etc/secret-volume
echo "$(cat /etc/secret-volume/username)"
echo "$(cat /etc/secret-volume/password)"
```

### (2).使用单个 Secret 数据绑定容器变量

```shell

kubectl create secret generic backend-user --from-literal=backend-username='backend-admin'

cat > pods/pod-single-secret-env-variable.yaml <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: env-single-secret
spec:
  containers:
  - name: envars-test-container
    image: nginx
    env:
    - name: SECRET_USERNAME
      valueFrom:
        secretKeyRef:
          name: backend-user
          key: backend-username
EOF

kubectl apply -f pods/pod-single-secret-env-variable.yaml

kubectl exec -i -t env-single-secret -- /bin/sh -c 'echo $SECRET_USERNAME'

```

### (3).使用多个 Secret 数据绑定容器变量

```shell
kubectl create secret generic backend-user --from-literal=backend-username='backend-admin'
kubectl create secret generic db-user --from-literal=db-username='db-admin'

cat > pods/pod-multiple-secret-env-variable.yaml <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: envvars-multiple-secrets
spec:
  containers:
  - name: envars-test-container
    image: nginx
    env:
    - name: BACKEND_USERNAME
      valueFrom:
        secretKeyRef:
          name: backend-user
          key: backend-username
    - name: DB_USERNAME
      valueFrom:
        secretKeyRef:
          name: db-user
          key: db-username
EOF

kubectl apply -f pods/pod-multiple-secret-env-variable.yaml

kubectl exec -i -t envvars-multiple-secrets -- /bin/sh -c 'env | grep _USERNAME'
```

### (4).将 Secret 中的所有键值偶对定义为环境变量

```shell
kubectl create secret generic test-secret --from-literal=username='my-app' --from-literal=password='39528$vdg7Jb'

cat > pods/pod-secret-envFrom.yaml <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: envfrom-secret
spec:
  containers:
  - name: envars-test-container
    image: nginx
    envFrom:
    - secretRef:
        name: test-secret
EOF

kubectl apply -f pods/pod-secret-envFrom.yaml

kubectl exec -i -t envfrom-secret -- /bin/sh -c 'echo "username: $username\npassword: $password\n"'
```





## 4.使用案例

### (1).包含 SSH 密钥的 Pod

```shell
kubectl create secret generic ssh-key-secret \
  --from-file=ssh-privatekey=/path/to/.ssh/id_rsa \
  --from-file=ssh-publickey=/path/to/.ssh/id_rsa.pub
  
  
apiVersion: v1
kind: Pod
metadata:
  name: secret-test-pod
  labels:
    name: secret-test
spec:
  volumes:
  - name: secret-volume
    secret:
      secretName: ssh-key-secret
  containers:
  - name: ssh-test-container
    image: mySshImage
    volumeMounts:
    - name: secret-volume
      readOnly: true
      mountPath: "/etc/secret-volume"
  
```

### (2).挂载隐藏文件

```shell
apiVersion: v1
kind: Secret
metadata:
  name: dotfile-secret
data:
  .secret-file: dmFsdWUtMg0KDQo=
---
apiVersion: v1
kind: Pod
metadata:
  name: secret-dotfiles-pod
spec:
  volumes:
  - name: secret-volume
    secret:
      secretName: dotfile-secret
  containers:
  - name: dotfile-test-container
    image: k8s.gcr.io/busybox
    command:
    - ls
    - "-l"
    - "/etc/secret-volume"
    volumeMounts:
    - name: secret-volume
      readOnly: true
      mountPath: "/etc/secret-volume"
      
卷中将包含唯一的叫做 .secret-file 的文件。 容器 dotfile-test-container 中，该文件处于 /etc/secret-volume/.secret-file 路径下。ls -la 可以看
```


### (3). 拉取私有镜像

ImagePullSecret：Pod 拉取私有镜像仓库时使用的账户密码，里面的账户信息，会传递给 kubelet ，然后 kubelet 就可以拉取有密码的仓库里面的镜像。

```shell
# 创建私有镜像仓库的 secret
kubectl create secret docker-registry docker-secret --docker-server=hub.docker.com --docker-username=admin --docker-password=password --docker-email=xxx@xxx.com

# 查看 docker-secret
kubectl get secret docker-secret -o yaml

# 解码就可以看到 docker 镜像的地址，Username password
echo "eyJhdXRocyI6eyJodWIuZG9ja2VyLmNvbSI6eyJ1c2VybmFtZSI6ImFkbWluIiwicGFzc3dvcmQiOiJwYXNzd29yZCIsImVtYWlsIjoieHh4QHh4eC5jb20iLCJhdXRoIjoiWVdSdGFXNDZjR0Z6YzNkdmNtUT0ifX19" | base64 --decode 


# 配置使用docker-secret 拉取私有镜像的时候就好了
cat > pod/docker-pull-nginx1.yaml << EOF
apiVersion: v1
kind: Pod
metadata:
  name: nginx-sa1
  namespace: default
spec:
  containers:
    - name: nginx-sa1
      image: registry.cn-hangzhou.aliyuncs.com/xzqk8s/nginx:1.7.9
      imagePullPolocy: Always
  imagePullSecret:
  - name: docker-secret
EOF

kubectl apply -f pod/docker-pull-nginx1.yaml
```


# 热更新 ConfigMap 和 Secret

ConfigMap 和 Secret 如果是以 subPath 的形势挂载的，那么 Pod 是不会感知到 ConfigMap 和 Secret 的更新的。如果 Pod的变量来自于 ConfigMap 和 Secret 中定义的内容，那么 ConfigMap 和 Secret 的更新后，也不会更新 Pod 中的变量。这种通过挂载到其他目录，然后在postStart 中创建软连接的方式，连接到 /etc/nginx/nginx.conf 这种方式

### edit

```shell
# 直接编辑，resourceVersion 这个值每次更新都会改变
kubectl edit cm nginc-conf
```

### create

```shell
bim nginx.conf # 把 worker_processes 改成 3
kubectl create cm nginx-conf --from-file=nginx.conf --dry-run -oyaml
kubectl create cm nginx-conf --from-file=nginx.conf --dry-run=client -oyaml | kubectl replace -f -
```














